# book1
В целом я предпочитаю использовать марковскую нотацию процесса принятия ре-
шений Томаса и Окала, версию 1. Однако я попытался еще больше упростить ее,
убрав такие формальности, как разграничение по времени, и расширив использова-
ние апострофа для обозначения текущего и следующего моментов. Во всей матема-
тической строгости эти концепции изложены в академических учебниках и статьях.
Как правило, фигурные буквы обозначают множество, а строчны́е буквы — эле-
мент множества. Апостроф обозначает следующий временно́й шаг. Прописные
буквы представляют функцию или константу.
Я отказываюсь от формальности выборки определенного состояния из случай-
ной переменной и вместо этого использую конкретную реализацию перемен-
ной, например s , чтобы облегчить читаемость уравнений. В литературе вы
обычно встретите заглавные буквы, представляющие стохастические перемен-
ные.
Некоторые алгоритмы насыщены индексами, и это означает, что вам нужно буфе-
ризовать данные и обращаться к определенным точкам в получившемся буфере.
Когда я получаю эти алгоритмы, мне приходится прибегать к использованию
нижних индексов; например t
a будет означать действие в какой-то момент времени
или позиции t .
Если вы не привыкли читать уравнения, делайте это медленно. Сначала посмотри-
те, чтобы понять, что представлено каждым символом, а затем определите, что
в этом уравнении делается. Как и в случае с любым навыком, чем больше раз вы
будете выполнять его, тем проще станет для вас процесс выполнения. Знак "точка
равно"  можно читать как "определяется как".
Изучая алгоритмы, прочтите их процедурно. Где возможно, я использую текст, но
во многих случаях уравнение оказывается более кратким. Символ ← в алгоритмах
читается как "обновить"; это предпочтительнее, потому что технически знак равен-
ства означает математическое равенство, например == в вашем программном
обеспечении. Большинство языков программирования злоупотребляют этой но-
тацией и используют символ равенства для обозначения как определения, так и
обновления.
Я решил представить алгоритмы в академическом псевдокоде, а не в стиле, приня-
том в программной инженерии. Я долго думал об этом, но в итоге есть три основ-
ные причины для этого решения. Во-первых, так алгоритмы представлены во всей
академической литературе. Я хотел, чтобы эта книга стала мостиком между про-
мышленным и академическим сообществом, и я думаю, что наличие еще одного
представления усилит этот разрыв. Во-вторых, эти алгоритмы более лаконичны
в академической форме, такова математика. Если бы вам пришлось преобразовать
математику в программный псевдокод, это привело бы к огромному количеству
циклов for и временны́х переменных. Последняя причина в том, что ошибиться бы-
ло бы слишком легко. Несмотря на то что я упростил математику, псевдокод пред-
ставляет собой реальную реализацию. Преобразование реализаций, представлен-
ных в академических статьях, в программный псевдокод привело бы к слишком
большому количеству ошибок.
